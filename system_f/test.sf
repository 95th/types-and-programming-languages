let func = \X (\c: {None | Some X}. \x: X->(X, X). 
	case c of 
		| None => None of {None | Some (X, X)}
		| Some val => Some (val, val) of {None | Some (X, X)} )
in func [Nat] (Some 10 of {None|Some Nat}) (\x: Nat. (x, x))
;

let poly = \X \x: X. x in 
	let x = poly [Nat] 0 in 
	let y = poly [Bool] false in 
	let z = poly [(Nat, Bool)] in 
	z (x, y)
;

let poly = \X \Y (\func: X->Y. \val: X. func val) in poly [Nat][Bool]
;


case Some (5, 2) of {None | Some (Nat, Nat)} of 
 | None => (0, 0)
 | Some (1, _) => (1, 1)
 | Some(x, y) => (y, x)
;

case (1, (2, 3)) of 
	| (x, (y, z)) => (z, y, x)
;
let x = 
	\z: (Nat, Nat)->Nat. 
		\y: (Nat, Nat).
			case y of
				| (0, x) => x,
				| x => z (pred y.0, succ (succ x.1))
	in (fix x) (10, 0)

;
let add = \f: Nat->Nat->Nat. \m: Nat. \n: Nat.
	case m of 
		| 0 => 0,
		| x => succ (f (pred m) n)
in (fix add) 5 3;